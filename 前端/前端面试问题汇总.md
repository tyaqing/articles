

# 基本问题

## 自我介绍

​		您好，我叫滕亚庆，湖南人，是25岁年的,今天来是想面试贵公司的web前端岗位，我想从以下三个方面介绍自己。

​		我接触前端已经5年了,大学的时候就是独立开发者,我之前的工作是在广州一家新兴教育机构做前端负责人,负责教务管理产品开发,也给我积累了很多的react相关的实战经验.

​		现在主要的技术栈是react.比较喜欢学习新技术,喜欢将新技术实践在产品里面,工作之余也会经常写一些开源组件,看一些技术博客.因为个人也比较喜欢折腾产品,会想尽办法优化它.未来我希望首先能够在前端方面独当一面,然后钻研产品,目标是技术型产品经理.

​		虽然我接触的面很广,但是很多地方还缺乏应有的深度,我还是会不畏难的去学习,我希望能加入贵公司贡献自己的一份力量,在贡献小力量的同时慢慢的提升自己的能力,在为公司产生价值的同时实现自己的价值.

## 介绍自己的项目-课程驾到

### 课程驾到

### 项目的背景是什么；

学生增多带来的排课,问题

老师增多带来的工资计算问题

多校区带来的调课

老师评级与课时费

### 当前项目的目的是什么；

教育办公无纸化

### 在开发过程中，你的角色是什么；

前端负责人;根据需求和设计完成前端的界面和逻辑

### 在开发过程中有遇到过什么样的难题；

1. 父子组件传值问题引入dva
2. 课表过滤的函数在很多界面中需要使用,用高阶组件包装了一下
3. 使用别人的框架antd admin需要填坑,需要发issue提问,有些pullrequest了



issue,Stack Overflow

### 项目完成之后，取得了哪些成果；



问：您对我面试的评价？ 

  答：计算机基础还需要强化，另外需要有一个明确的发展规划 

  问：你们部门主要用那些技术栈？ 

  答：偏全栈，[前端]()主要是Vue/React，后端node/Java 

  问：我面试通过了吗？  

  答： 一周内会通知

# Javascript

## 1.什么是原型链

- 

## 2.什么是是构造函数

只要能通过new来调用的就可以作为构造函数.

#### new的过程

1. 创建一个空对象 obj ，分配内存空间
2. 从参数列表中获取构造函数，并将 `obj` 的 `__proto__` 属性指向构造函数的 `prototype`
3. 通过 `apply` 执行构造，并将当前 `this` 的指向改为 `obj`
4. 返回构造函数的执行结果，或者当前的 `obj` 对象



3. 



### toString 与 valueIOf区别[待完成]

## Number相关问题

### 怎么判断小数



### 精度丢失问题

浮点数的精度丢失不仅仅是js的问题， java 也会出现精度丢失的问题（没有黑java），主要是因为数值在内存是由二进制存储的，而某些值在转换成二进制的时候会出现无限循环，由于位数限制，无限循环的值就会采用“四舍五入法”截取，成为一个计算机内部很接近数字，即使很接近，但是误差已经出现了。

**解决办法：**可在操作前，放大一定的倍数，然后再除以相同的倍数

### toFixed可以做到四舍五入么

```javascript
// 使用 Math.round 可以四舍五入的特性，把数组放大一定的倍数处理
function round(number, precision) {
    return Math.round(+number + 'e' + precision) / Math.pow(10, precision);
}
```

原理是，`Math.round` 是可以做到四舍五入的，但是仅限于正整数，那么我们可以放大至保留一位小数，计算完成后再缩小倍数。

### 不同进制如何转换

10 进制转其他进制：`Number(val).toString([2,8,10,16])`

其他进制转成10进制：`Number.parseInt("1101110",[2,8,10,16])`

其他进制互转：先将其他进制转成 10 进制，在把 10 进制转成其他进制

## js处理二进制的了解

ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区，作为内存区域，可以存放多种类型的数据，它不能直接读写，只能通过视图来读写。

同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view），视图的作用是以指定格式解读二进制数据。目前有两种视图，一种是 `TypedArray` 视图，另一种是 `DataView` 视图，两者的区别主要是字节序，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。

Blob: 也是存放二进制的容器，通过 `FileReader` 进行转换。

之前有做过简单的总结，大家可以看看：[nodejs 二进制与Buffer](https://juejin.im/post/5d188e1fe51d454fd8057bc9)

毕竟对这块应用的比较少，推荐一篇文章给大家 [二进制数组](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html)

## 异步方案

这个问题出场率很高呀！常见的有如下几个：

- `回调函数`：通过嵌套调用实现
- `Generator`: 异步任务的容器，生成器本质上是一种特殊的迭代器， Generator 执行后返回的是个指针对象，调用对象里的 next 函数，会移动内部指针，分阶段执行 `Generator` 函数 ，指向 `yield` 语句，返回一个对象 {value:当前的执行结果，done:是否结束}
- `promise`: 而是一种新的语法糖， Promise 的最大问题是代码冗余，通过 then 传递执行权，因为需求手动调用 then 方法，当异步函数多的时候，原来的语义变得很不清楚
- `co`: 把 Generator 和 Promise 封装，达到自动执行
- `async\await`: 目前是es7草案，可通过 `bable webpack` 等工具提前使用，目前原生浏览器支持还不太好。其本质上是语法糖，跟 co 库一样，都是对 `generator+promise` 的封装，不过相比 co ，语义化更好，可以像普通函数一样调用，且大概率是未来的趋势。

怎么评判每个异步的的优缺点呢:

1. 阅读性
2. 

### 回调函数

- 回调函数有一个致命的弱点，就是容易写出**回调地狱（Callback hell）**
- 不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数
- 此外它不能使用 try catch 捕获错误，不能直接 return。

### Promise

Promise 已经是 ES6 的规范了，相比 Generator ，设计的更加合理和便捷。

看看Promise的规范：

1. 一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected），状态的改变只能是单向的，且变化后不可在改变。
2. 一个 Promise 必须提供一个 then 方法以访问其当前值、终值和据因。 promise.then(onFulfilled, onRejected) 回调函数只能执行一次，且返回 promise 对象

promise 的每个操作返回的都是 promise 对象，可支持链式调用。通过 then 方法执行回调函数，Promise 的回调函数是放在事件循环中的微队列。

#### Promise.all的实现

```js
function promiseAll(promiseArray) {
    return new Promise(function (resolve, reject) {
        if (!Array.isArray(promiseArray)) {
            throw new TypeError(`argument must be a array`)
        }

        let resolvedCounter = 0;
        let promiseNum = promiseArray.length;
        let resolvedResult = [];

        for (let i = 0; i < promiseNum; i++) {
            Promise.resolve(promiseArray[i]).then(
                value => {
                    resolvedCounter++;
                    resolvedResult[i] = value;
                    if (resolvedCounter == promiseNum) {
                        return resolve(resolvedResult)
                    }
                },
                reason => {
                    return reject(error)
                }
            )
        }
    })
}
```

- 比如无法取消 Promise
- 错误需要通过回调函数捕获

### Generator

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。

- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
- **Generator 函数除了状态机，还是一个遍历器对象生成函数**。
- **可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果**。
- yield表达式本身没有返回值，或者说总是返回undefined。**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值**。

#### generator解决了什么问题

原来那种回调异步模式，代码时间长了，回过头来看，有可能出现自己都看不明白的危险。有了generator，同步表达就容易理解得多，但编码的时候还是偏向异步思维方式，需要透彻的理解回调异步。

**最完美的异步模式是没有显式的异步，代码不需要generator/yield或者async/await的包装转换，就是直接写同步代码，思维方式也是同步的，也不需要理解回调异步。**

- 执行流程管理不方便，异步返回的值需要手动传递，编码上较容易出错。

> 关于引入generator的目的 https://cnodejs.org/topic/56ded164255ed94c6e4c26c6

#### co库及其源码浅析

[co库](https://github.com/tj/co)是一个利用generator和Promise让异步代码更直观的辅助库，它的使用形式如下。

```js
import co from 'co';

co(function* () {
    const result = yield Promise.resolve(true);
    return result;
}).then(function (value) {
    console.log(value);
}, function (err) {
    console.error(err.stack);
});
```

### Async/Await

所以说`async/await`就是`generator` + `promise`的语法糖

1、async函数自带执行器，自动执行，无需next
2、yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
3、async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator,比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。

- 目前还有部分不兼容,需要babel换成promise才可以用

### 总结

**1.JS 异步编程进化史：callback -> promise -> generator -> async + await**

**2.async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。**

**3.async/await可以说是异步终极解决方案了。**

**(1) async/await函数相对于Promise，优势体现在**：

- 处理 then 的调用链，能够更清晰准确的写出代码
- 并且也能优雅地解决回调地狱问题。

当然async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。

**(2) async/await函数对 Generator 函数的改进，体现在以下三点**：

- 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，**async 函数的执行，与普通函数一模一样，只要一行**。
- 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 **async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）**。
- 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。




## 垃圾回收机制

为什么需要垃圾回收：因为对象需要占用内存，而内存资源是有限的。

js 会周期性的对不在使用的对象销毁，释放内存，关键点就在于怎么识别哪些对象是垃圾。

垃圾对象：对象没有被引用，或者几个对象形成循环引用，但是根访问不到他们，这些都是可回收的垃圾。

垃圾回收的两种机制：标记清除和引用计数

#### 标记清除法

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

比如说函数中声明了一个变量，就做一个标记，当函数执行完成，退出执行栈，这个变量的标记就变成已使用完。

目前主流浏览器采用的是这个策略

#### 引用计数

跟踪每个值被引用的次数，声明一个变量后，这个变量每被其他变量引用一次，就加 1 ，如果变量引用释放了，就减 1，当引用次数为 0 的时候，对象就被清理。但这个有个循环引用的弊端，所以应用的比较少。

#### 垃圾收集的性能优化

1. 分代回收，对象分成两组，新生带、老生带，
2. 增量回收
3. 空闲时间回收

#### 编码可以做的优化

1. 避免重复创建对象。
2. 在适当的时候解除引用，是为页面获的更好性能的一个重要方式。
3. 全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

## 什么是严格模式

通过在脚本的最顶端放上一个特定语句 `"use strict";` 整个脚本就可开启严格模式语法。

严格模式下有以下好处：

1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
2. 消除代码运行的一些不安全之处，保证代码运行的安全；
3. 提高编译器效率，增加运行速度；
4. 为未来新版本的Javascript做好铺垫。

如以下具体的场景：

1. 严格模式会使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常
2. 严格模式下的 eval 不再为上层范围(surrounding scope,注:包围eval代码块的范围)引入新变量
3. 严格模式禁止删除声明变量
4. 在严格模式中一部分字符变成了保留的关键字。这些字符包括implements, interface, let, package, private, protected, public, static和yield。在严格模式下，你不能再用这些名字作为变量名或者形参名。
5. 严格模式下 arguments 和参数值是完全独立的，非严格下修改是会相互影响的

## map 和 weekMap区别

`map` 的 `key` 可以是任意类型，在 `map` 内部有两个数组，分别存放 `key` 和 `value` ，用下标保证两者的一一对应，在对 `map` 操作时，内部会遍历数组，时间复杂度O(n)，其次，因为数组会一直引用每个键和值，回收算法没法回收处理，可能会导致内存泄露。

相比之下， `WeakMap` 的键值必须是对象，持有的是每个键对象的 `弱引用` ，这意味着在没有其他引用存在时垃圾回收能正确进行。

```javascript
const wm1 = new WeakMap();
const o1 = {};
wm1.set(o1, 37);  // 当 o1 对象被回收，那么 WeakMap 中的值也被释放
```

### WeekSet

JavaScript垃圾回收是一种内存管理技术。在这种技术中，不再被引用的对象会被自动删除，而与其相关的资源也会被一同回收。Set中对象的引用都是强类型化的，并不会允许垃圾回收。这样一来，如果Set中引用了不再需要的大型对象，如已经从DOM树中删除的DOM元素，那么其回收代价是昂贵的。

为了解决这个问题，ES6还引入了WeakSet的弱集合。这些集合之所以是“弱的”，是因为它们允许从内存中清除不再需要的被这些集合所引用的对象。

首先让我们了解下WeakSet与Set的不同，以下三点是WeakSet与Set不一样的地方：

1. Set可以存储值类型和对象引用类型，而WeakSet只能存储对象引用类型，否则会抛出TypeError。
2. WeakSet不能包含无引用的对象，否则会被自动清除出集合（垃圾回收机制）。
3. WeakSet对象是不可枚举的，也就是说无法获取大小，也无法获取其中包含的元素。




## 判断数组的方法

这题主要还是考察对原型链的理解

1. `Array.isArray()` ES6 api
2. `obj instanceof Array` 原型链查找
3. `obj.constructor === Array` 构造函数类型判断
4. `Object.prototype.toString.call(obj) === '[object Array]'` toString
   返回表示该对象的字符串，若这个方法没有被覆盖，那么默认返回 `"[object type]"` ，其中 `type` 是对象的类型。需要准确判断类型的话，建议使用这种方法

## 循环有几种，是否支持中断和异步

- for 支持中断、支持异步事件
- for of 支持中断、支持异步事件
- for in 支持中断、支持异步事件
- forEach 不支持中断、不支持异步事件
- map 不支持中断、不支持异步事件，支持异步处理方法：map 返回promise数组，在使用 Promise.all 一起处理异步事件数组
- reduce 不支持中断、不支持异步事件，支持异步处理方法：返回值返回 promise 对象

map 的比较简单就不写了，我写个 `reduce` 处理 `async/await` 的 demo

```javascript
const sleep = time => new Promise(res => setTimeout(res, time))
async function ff(){
    let aa = [1,2,3]
    let pp = await aa.reduce(async (re,val)=>{
        let r = await re;
        await sleep(3000)
        r += val;
        return Promise.resolve(r)
    },Promise.resolve(0))
    console.log(pp) // 6
}
ff()
```

## 扩展运算符...

这题面试官估计是想知道你是不是真的用过 es6 吧

扩展运算符（…）也会调用默认的 Iterator 接口。

扩展运算符主要用在不定参数上，可以将参数转成数组形式

```javascript
function fn(...arg){
    console.log(arg) // [ 1, 2, 3 ]
}
fn(1,2,3)
```

## 进程和线程

首先来一句话概括：进程和线程都是一个时间段的描述，都是对CPU工作时间段的描述。

当一个任务得到 CPU 资源后，需要加载执行这个任务所需要的执行环境，也叫上下文，进程就是包含上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文。可见进程的颗粒度太大，每次都需要上下文的调入，保存，调出。

如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。

那么这里具体的执行就是：程序A得到CPU => CPU加载上下文 => 开始执行程序A的a小段 => 然后执行A的b小段 => 然后再执行A的c小段 => 最后CPU保存A的上下文。这里a，b，c 的执行共享了A的上下文，CPU在执行的时候没有进行上下文切换的。

a，b，c 我们就是称为线程，就是说线程是共享了进程的上下文环境，是更为细小的 CPU 执行时间段。

![单线程与多线程的进程对比图](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/3380f0a16c323deda5d3a300804b95da.png)

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

总结来说，进程和线程之间的关系有以下 4 个特点。

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

## 函数式编程

函数式编程的两个核心：合成和柯里化，之前对函数式编程做过总结，传送门：[【面试官问】你懂函数式编程吗？](https://juejin.im/post/5cc475e5f265da035d0c83da)

https://juejin.im/post/6844903936378273799

## 尾递归

先给面试官简单说下什么是递归函数：函数内部循环调用自身的就是递归函数，若函数没有执行完毕，执行栈中会一直保持函数相关的变量，一直占用内存，当递归次数过大的时候，就可能会出现内存溢出，也叫爆栈，页面可能会卡死。
所以为了避免出现这种情况，可以采用尾递归。

尾递归：在函数的最后一步是调用函数，进入下一个函数不在需要上一个函数的环境了，内存空间 O(n) 到 O(1) 的优化 ，这就是尾递归。
尾递归的好处：可以释放外层函数的调用栈，较少栈层级，节省内存开销，避免内存溢出。

网上很多用斐波那契数列作为栗子，但我偏不，我用个数组累加的栗子

```javascript
function add1(arr) {
    if (arr.length === 0) {
        return 0
    }
    return add1(arr.slice(1)) + arr[0] // 还有父级函数中 arr[0] 的引用
}

function add(arr, re) {
    if (arr.length === 0) {
        return re + 0
    } else {
        return add(arr.slice(1), arr[0] + re) // 仅仅是函数调用
    }
}

console.log(add([1, 2, 3, 4], 0))  // 10
console.log(add1([1, 2, 3, 4])) // 10
```

## 观察者模式、发布-订阅者模式的区别

两者都是订阅-通知的模式，区别在于：

观察者模式：观察者和订阅者是互相知道彼此的，是一个紧耦合的设计

发布-订阅：观察者和订阅者是不知道彼此的，因为他们中间是通过一个订阅中心来交互的，订阅中心存储了多个订阅者，当有新的发布的时候，就会告知订阅者

设计模式的名词实在有点多且绕，我画个简单的图：

![dingyue](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/format,png-20200923165216403.png)

## 深克隆

```js
function deepCopy(obj) {
  // 主要判断基本类型 object function array
  let newObj = Array.isArray(obj) ? [] : {};
  if (obj && typeof obj === "object") {
    for (let key in obj) {
      // 如果子节点是对象继续克隆,如果不是object就直接赋值了
      newObj[key] =
        typeof obj[key] === "object" ? deepCopy(obj[key]) : obj[key];
    }
  }
  return obj;
}
let a = {
  a: {},
  b: [1, 2, 3, { a: { b: "name" } }],
  c: function () {},
};
let d = deepCopy(a);
console.log(d);
```

## 浏览器端数据存储方案

在浏览器端存储数据对我们是很有用，这相当于赋予浏览器记忆的功能，可以纪录用户的所有状态信息，增强用户体验。比如当纪录用户的登陆状态时，可以让用户能够更快的进行访问，而不是每次登陆时都需要去进行繁琐的操作。

总的来说,现在市面上最常见的数据存储方案是以下三种：

- Cookie
- web存储 (localStorage和seesionStorage)
- IndexedDB

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/172f8ee1105d5ae0.png)

## Cookie

Cookie的又称是HTTP Cookie，最初是在客户端用于存储会话信息，从底层来看，它作为HTTP协议的一种扩展实现，Cookie数据会自动在web浏览器和web服务器之间传输，因此在服务器端脚本就可以读写存储的cookie的值，因此Cookie通常用于存储一些通用的数据，比如用户的登陆状态，首选项等。虽然随着时代的进步，HTML5所提供的web存储机制已经逐步替代了Cookie，但有些较为老的浏览器还是不兼容web存储机制，因此正处于这个老旧更替阶段的我们对于它还是要了解了解的。(比如我这个瓜皮还在用它，2333)

### Cookie的优点

首先由于操作Cookie的API很早就已经定义和实现了，因此相比于其他的数据存储方式，Cookie的兼容性非常的好，兼容现在市面上所有的主流浏览器，我们在使用它的时候完全不用担心兼容问题。

### Cookie的缺点

说到Cookie的缺点，那就有点多了，不然也不会在Cookie后面出现web存储等新的数据存储的方案了。 总结起来Cookie的缺点主要是以下几点：

1. 存储量小。虽不同浏览器的存储量不同，但基本上都是在4kb左右。
2. 影响性能。由于Cookie会由浏览器作为请求头发送，因此当Cookie存储信息过多时，会影响特定域的资源获取的效率，增加文档传输的负载。
3. 只能储存字符串。
4. 安全问题。存储在Cookie的任何数据可以被他人访问，因此不能在Cookie中储存重要的信息。
5. 由于第三方Cookie的滥用，所以很多老司机在浏览网页时会禁用Cookie，所以我们不得不测试用户是否支持Cookie，这也是很麻烦的一件事。

### Cookie的操作

基本的Cookie操作主要有三个：读取，写入和删除。但在JavaScript中去处理cookie是一件很繁琐的事情，因为cookie中的所有的名字和值都是经过URI编码的，所以当我们必须使用decodeURICompoent来进行解码才能得到cookie的值。我们来看看CookieUtil对象是如何操纵cookie的：

```
var CookieUtil = {
	// get可根据cookie的名字获取相应的值
	get: function() {
		const cookieName = encodeURIcOMPONET(name) + "=",
			   cookieStart = document.cookie.indexOf(cookieName),
			   cookieValue = null
		if(cookieStart > -1) {
			const cookieEnd = document.cookie.indexOf(";", cookieStart)
			if(cookieEnd == -1) {
				cookieEnd = document.cookie.length
			}
			cookieValue = decodeURICompoent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))	
		}
		return cookieValue
	}
	// set设置一个cookie
	set: function(name, value, expires, path, domain, secure) {
		var cookieText = encodeURIComponet(name)+"="+encodeURIComponet(value)
		if(expires instanceof Date) {
			cookieText += "; expires=" + expires.toGMTString()
		}
		if(path) {
			cookieText += ";path=" + path
		}
		if(domain) {
			cookieText += "; domain" + domain
		}
		if(secure) {
			cookieText += "; secure"
		}
		document.cookie = cookieText
	}
	// 删除已有的cookie
	unset: function(name, path, domain, secure) {
		this.set(name, "", new Date(0), path, domain, secure)
	}
}
复制代码
```

是不是很麻烦，无论是获取一个cookie的值或是设置一个cookie都是很麻烦的事情，这也成为了后续的浏览器数据存储方案出现的一大原因。

## web存储

web存储机制最初作为HTML5的一部分被定义成API的形式，但又由于其本身的独特性与其他的一些原因而剥离了出来，成为独立的一个标准。web存储标准的API包括locaStorage对象和seesionStorage对象。它所产生的主要原因主要出于以下两个原因：

- 人们希望有一种在cookie之外存储回话数据的途径。
- 人们希望有一种存储大量可以跨会话存在的数据的机制。

（注：其实在最初的web存储规范中包含了两种对象的定义：seesionStorage和globalStorage,这两个对象在支持这两个对象的浏览器中都是以windows对象属性的形式存在的）

### localStorage

localStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了我们上面所提到的globalStorage。从功能上来讲，我们可以通过locaStorage在浏览器端存储键值对数据，它相比于cookie而言，提供了更为直观的API，且在安全上相对好一点 ，而且虽然localStorage只能存储字符串，但它也可以存储字符串化的JSON数据，因此相比于cookie，localStorage能存储更复杂的数据。总的来说相较于cookie，localStorage有以下优势：

- 提供了简单明了的API来进行操作
- 更加安全
- 可储存的数据量更大

也正是出于以上这些原因，localStorage被视为替代cookie的解决方案，但还是要注意不要在localStorage中存储敏感信息。

#### localStorage的基本语法

localStorage的基本操作很简单，示例如下：

```
// 使用方法存储数据
localStorage.setItem("name", "Srtian")
// 使用属性存储数据
localStorage.say = "Hello world"
// 使用方法读取数据
const name = localStorage.getItem("name")
// 使用属性读取数据
const say = localStorage.say
// 删除数据
localStorage.removeItem("name")
复制代码
```

但需要注意的是，我们上面的示例全是存储字符串格式的数据，当我们需要传输其他格式的数据时，我们就需要将这些数据全部转换为字符串格式，然后再进行存储：

```
const user = {name:"Srtian", age: 22}
localStorage.setItem("user", JSON.stringify(user))
复制代码
```

当然，我们在获取值的时候也别忘了将其转化回来：

```
var age = JSON.parse(localStorage.user)
复制代码
```

#### localStorage储存数据的有效期与作用域

通过localStorage存储的数据时永久性的，除非我们使用removeItem来删除或者用户通过设置浏览器配置来删除，负责数据会一直保留在用户的电脑上，永不过期。

localStorage的作用域限定在文档源级别的（意思就是同源的才能共享），同源的文档间会共享localStorage的数据，他们可以互相读取对方的数据，甚至有时会覆盖对方的数据。当然，localStorage的作用域同样也受浏览器的限制。

#### localStorage的兼容

localStorage的兼容如下表所示：

```
    Feature 	Chrome 	Edge 	Firefox (Gecko) Internet Explorer 	Opera 	Safari (WebKit)
localStorage 	4 	(Yes) 	   3.5 	            8 	             10.50     4
sessionStorage 	5 	(Yes) 	   2 	            8 	             10.50 	   4
复制代码
```

### sessionStorage

sessionStorage是web存储机制的另一大对象，sessionStorage 属性允许我们去访问一个 session Storage 对象。它与 localStorage 相似，不同之处在于 localStorage里面存储的数据没有过期时间设置，而Session Storage只存储当前会话页的数据，且只有当用户关闭当前会话页或浏览器时，数据才会被清除。

#### sessionStorage的基本语法

我们可以通过下面的语法，来保存，获取，删除数据，大体语法与：

```
// 保存数据到sessionStorage
sessionStorage.setItem('name', 'Srtian');

// 从sessionStorage获取数据
var data = sessionStorage.getItem('name');

// 从sessionStorage删除保存的数据
sessionStorage.removeItem('name');

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
复制代码
```

下面的示例会自动保存一个文本输入框的内容，如果浏览器因偶然因素被刷新了，文本输入框里面的内容会被恢复，写入的内容不会丢失：

```
// 获取文本输入框
var field = document.getElementById("field")

// 检测是否存在 autosave 键值
// (这个会在页面偶然被刷新的情况下存在)
if (sessionStorage.getItem("autosave")) {
  // 恢复文本输入框的内容
  field.value = sessionStorage.getItem("autosave")
}
// 监听文本输入框的 change 事件
field.addEventListener("change", function() {
  // 保存结果到 sessionStorage 对象中
  sessionStorage.setItem("autosave", field.value)
})
复制代码
```

在兼容性和优点方面，sessionStorage和localStorage是差不多的，因此在此也就不多说了，下面我们来聊一聊IndexedDB。

## IndexedDB

虽然web存储机制对于存储较少量的数据非常便捷好用，但对于存储更大量的结构化数据来说，这种方法就不太满足开发者们的需求了。IndexedDB就是为了应对这个需求而产生的，它是由HTML5所提供的一种本地存储，用于在浏览器中储存较大数据结构的 Web API，并提供索引功能以实现高性能查找。它一般用于保存大量用户数据并要求数据之间有搜索需要的场景，当网络断开时，用户就可以做一些离线的操作。它较之SQL更为方便，不需要写一些特定的语法对数据进行操作，数据格式是JSON。

### IndexedDB的基本语法

使用IndexedDB在浏览器端存储数据会比上述的其他方法更为复杂。首先，我们需要创建数据库，并指定这个数据库的版本号：

```
// 注意数据库的版本号只能是整数
const request = IndexedDB.open(databasename, version)
复制代码
```

然后我们需要生成处理函数，需要注意的是onupgradeneeded 是我们唯一可以修改数据库结构的地方。在这里面，我们可以创建和删除对象存储空间以及构建和删除索引。 ：

```
request.onerror = function() {
	// 创建数据库失败时的回调函数
}
request.onsuccess = function() {
	// 创建数据库成功时的回调函数
}
request.onupgradeneededd = function(e) {
	 // 当数据库改变时的回调函数
}

复制代码
```

然后我们就可以建立对象存储空间了，对象存储空间仅调用createObjectStore()就可以创建。这个方法使用存储空间的名称，和一个对象参数。即便这个参数对象是可选的，它还是非常重要的，因为它可以让我们定义重要的可选属性和完善你希望创建的对象存储空间的类型。

```
request.onupgradeneeded = function(event) {
	const db = event.target.result
	const objectStore = db.createObjectStore('name', { keyPath:'id' })
}
复制代码
```

对象的存储空间我们已经建立好了，接下来我们就可以进行一系列的骚操作了，比如来个蛇皮走位！不不不，口误口误，比如添加数据：

```
addData: function(db, storename, data) {
	const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
	for(let i = 0; i < data.length; i++) {
		const request = store.add(data[i])
		request.onerror = function() {
			console.error('添加数据失败')
		}
		request.onsuccess = function() {
			console.log('添加数据成功')
		}
	}
}
复制代码
```

如果我们想要修改数据，语法与添加数据差不多，因为重复添加已存在的数据会更新原本的数据，但还是有细小的差别：

```
putData: function(db, storename, data) {
	const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
	for(let i = 0; i < data.length; i++) {
		const request = store.put(data[i])
		request.onerror = function() {
			console.error('修改数据失败')
		}
		request.onsuccess = function() {
			console.log('修改数据成功')
		}
	}
}
复制代码
```

获取数据：

```
getDataByKey: function(db, storename, key) {
	const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
	const request = store.get(key)
	request.onerror = function() {
		console.error('获取数据失败')
	}
	request.onsuccess = function(e) {
		const result = e.target.result
		console.log(result)
	}
}
复制代码
```

删除数据：

```
deleteDate: function(db, storename, key) {
	const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
	store.delete(key)
	console.log('已删除存储空间' + storename + '中的' + key + '纪录')
}
复制代码
```

关闭数据库：

```
db.close
复制代码
```

### IndexedDB的优点（相较于前面的存储方案）

- 拥有更大的储存空间
- 能够处理更为复杂和结构化的数据
- 拥有更多的交互控制
- 每个'database'中可以拥有多个'database'和'table'

### IndexedDB的局限性

了解了IndexedDB的优点，我们当然也要来聊一聊IndexedDB的局限性与适用的场景：

#### 1. 存储空间限制

一个单独的数据库项目的大小没有限制。然而可能会限制每个 IndexedDB 数据库的大小。这个限制（以及用户界面对它进行断言的方式）在各个浏览器上也可能有所不同：

- Firefox: 对 IndexedDB 数据库的大小没有限制。在用户界面上只会针对存储超过 50 MB 大小的 BLOB（二进制大对象）请求权限。这个大小的限额可以通过 dom.indexedDB.warningQuota 首选项进行自定义。(定义在 [mxr.mozilla.org/mozilla-cen…](http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js))。
- Google Chrome：[developers.google.com/chrome...ra…](https://developers.google.com/chrome...rage#temporary)

#### 2. 兼容性问题

IndexedDB的兼容来讲比前面所提及的存储方案要差不少，因此在使用IndexedDB时，我们也要好好的考虑兼容性的问题

#### 3. indexedDB受同源策略的限制

indexedDB使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。要着重指出的一点是 IndexedDB 不适用于从另一个站点加载进框架的内容 (不管是  还是 。这是一项安全措施。详情请看这个：[bugzilla.mozilla.org/show_bug.cg…](https://bugzilla.mozilla.org/show_bug.cgi?id=595307)



除此之外，IndexedDB还存在诸如：不适合存储敏感数据，相较于web存储机制的操作更加复杂等问题，这都是我们在使用IndexedDB时需要考虑的。

## 防抖与节流

#### 函数防抖(debounce)

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
function debounce(func, delay) {
  let timeout;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(this, arguments);
    }, delay);
  };
}
```

#### 函数节流(throttle)

>  规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```js
// 利用时间戳
function throttle(func, frequence = 1000) {
  let timer = Date.now() + frequence;
  return function () {
    if (Date.now() < timer) return;
    func.apply(this, arguments);
    timer = Date.now() + frequence;
  };
}
// 利用定时器
function throttle2(func, frequence = 1000) {
  let timeout = null;
  return function () {
    if (timeout) return;
    timeout = setTimeout(() => {
      func.apply(this, arguments);
      timeout = null;
    }, frequence);
  };
}
```



## ES7 ECMA 2016 新特性

## ES8 ECMA2017 新特性

## ES9 ECMA2018 新特性

- globalThis

![截屏2020-09-23 上午2.13.41](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/截屏2020-09-23 上午2.13.41.png)



- Promise.allSettled:解决了Promise.all()不能定位错误的弊端,可以打印出哪一个promise除了问题
- Nullish coalescing operator 空位合并操作符 `??` 替代 之前逻辑或的操作符 ||     0||100 = 100  

* Optinal chaining operator 可选链操作符  obj={}  console.log(obj?.name?.money)// 这个不会报错

---

# React


## React 核心概念

### JSX 简介

#### 为什么使用 JSX

React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。

React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。

##### JSX 防止注入攻击

React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。

`JSX会自动删除空格符，换行符,原理可用正则替换`

### 元素渲染

**元素是构成 React 应用的最小砖块。**

特点:

1. 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。
2. React 只更新它需要更新的部分

```js
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById("root"));
}

setInterval(tick, 1000);
```

尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。

### 组件 & Props

> 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

#### 渲染组件

当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

#### Props 的只读性

组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。
所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。

### State & 生命周期

##### State

State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。

##### 正确地使用 State

1. 不要直接修改 State
   - 使用 setState();
   - 构造函数是唯一可以给 this.state 赋值的地方
2. State 的更新可能是异步的
   - 出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。
   - this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态
   - 具体可参考 [这个](href=https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17)
   ```js
   // 正确的访问方法
   this.setState((state, props) => ({
     // 这里相当于回调,当state更新完后,这里的回调才会执行,且state也是最新的
     counter: state.counter + props.increment,
   }));
   ```
3. State 的更新会被合并
   - 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。
   - 这里的合并是浅合并

##### 生命周期

具体参考[React.Component](https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle)

##### 挂载

当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：

- constructor()
- static getDerivedStateFromProps()
- render()
- componentDidMount()

##### 更新

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- static getDerivedStateFromProps()
- shouldComponentUpdate()
- render()
- getSnapshotBeforeUpdate()  
  - 另外值得一题的是，这个函数的出现，是因为接下来的React 17的异步渲染而准备的。
  - getSnapshotBeforeUpdate 方法**在 React 对视图做出实际改动（如 DOM 更新）发生前被调用，返回值将作为 componentDidUpdate 的第**三个参数。
- componentDidUpdate()

##### 卸载

当组件从 DOM 中移除时会调用如下方法：

- componentWillUnmount()

##### 错误处理

当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

- static getDerivedStateFromError()
- componentDidCatch()

##### 数据是向下流动的

不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。

这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。

组件可以选择把它的 state 作为 props 向下传递到它的子组件中：

### 事件处理

- 在 JavaScript 中，class 的方法默认不会绑定 this

```js
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };
    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState((state) => ({
      isToggleOn: !state.isToggleOn,
    }));
  }
  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? "ON" : "OFF"}
      </button>
    );
  }
}
ReactDOM.render(<Toggle />, document.getElementById("root"));
```

- 解决方法 1: class fields

```js
class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  // 注意: 这是 *实验性* 语法。
  handleClick = () => {
    console.log("this is:", this);
  };
  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}
```

- 解决方法 2: 使用箭头函数

`此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。`

```js
class LoggingButton extends React.Component {
  handleClick() {
    console.log("this is:", this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return <button onClick={() => this.handleClick()}>Click me</button>;
  }
}
```

### 条件渲染

- 与运算符 &&
- 三目运算符

### 列表 & Key

##### key

- 如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。

- key 只是在兄弟节点之间必须唯一

### 表单

##### 受控组件

在 HTML 中，表单元素（如 `<input>`、` <textarea>` 和 `<select>`）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。

我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

##### 处理多个输入

这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：

```js
  handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value
    });
  }
```

##### 受控输入空值

在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。

>  **也就是说,当 value 为 undefined 或 null 时,input 是可编辑的,为字符串时,是不可编辑的,需要通过输入事件来更新 state**

### 状态提升

> 通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。让我们看看它是如何运作的。

- 在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。
- 虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。
- 由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。

### 组合 VS 继承

> 我们推荐使用组合而非继承来实现组件间的代码重用。

- 插槽的形式

```js
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">{props.left}</div>
      <div className="SplitPane-right">{props.right}</div>
    </div>
  );
}

function App() {
  return <SplitPane left={<Contacts />} right={<Chat />} />;
}
```

## 高阶组件

[转载](https://github.com/brickspert/blog/issues/2)

### 作用

- 复用的高级技巧,减少相同代码的冗余

### 高阶组件定义

> a higher-order component is a function that takes a component and returns a new component.

翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。

理解了吗？看了定义似懂非懂？继续往下看。

### 函数模拟高阶组件

我们通过普通函数来理解什么是高阶组件哦~

最普通的方法，一个 welcome，一个 goodbye。两个函数先从 localStorage 读取了 username，然后对 username 做了一些处理。

```js
function welcome() {
  let username = localStorage.getItem("username");
  console.log("welcome " + username);
}
function goodbey() {
  let username = localStorage.getItem("username");
  console.log("goodbey " + username);
}

welcome();
goodbey();
```

我们发现两个函数有一句代码是一样的，这叫冗余唉。不好不好~（你可以把那一句代码理解成平时的一大堆代码）

我们要写一个中间函数，读取 username,他来负责把 username 传递给两个函数。

```js
function welcome(username) {
  console.log("welcome " + username);
}
function goodbey(username) {
  console.log("goodbey " + username);
}
function wrapWithUsername(wrappedFunc) {
  let newFunc = () => {
    let username = localStorage.getItem("username");
    wrappedFunc(username);
  };
  return newFunc;
}
welcome = wrapWithUsername(welcome);
goodbey = wrapWithUsername(goodbey);
welcome();
goodbey();
```

好了，我们里面的`wrapWithUsername`函数就是一个“高阶函数”。
他做了什么？他帮我们处理了 username，传递给目标函数。我们调用最终的函数 welcome 的时候，根本不用关心 username 是怎么来的。

我们增加个用户 study 函数。

```js
function study(username) {
  console.log(username + " study");
}
study = wrapWithUsername(study);

study();
```

这里你是不是理解了为什么说 wrapWithUsername 是高阶函数？我们只需要知道，用 wrapWithUsername 包装我们的 study 函数后，study 函数第一个参数是 username。

我们写平时写代码的时候，不用关心 wrapWithUsername 内部是如何实现的。

### 高阶组件

高阶组件就是一个没有副作用的纯函数。

我们把上一节的函数统统改成 react 组件。

最普通的组件哦。
welcome 函数转为 react 组件。

```js
import React, { Component } from "react";
class Welcome extends Component {
  constructor(props) {
    super(props);
    this.state = {
      username: "",
    };
  }
  componentWillMount() {
    let username = localStorage.getItem("username");
    this.setState({
      username: username,
    });
  }
  render() {
    return <div>welcome {this.state.username}</div>;
  }
}
export default Welcome;
```

goodbey 函数转为 react 组件。

```js
import React, { Component } from "react";
class Goodbye extends Component {
  constructor(props) {
    super(props);
    this.state = {
      username: "",
    };
  }
  componentWillMount() {
    let username = localStorage.getItem("username");
    this.setState({
      username: username,
    });
  }
  render() {
    return <div>goodbye {this.state.username}</div>;
  }
}
export default Goodbye;
```

现在你是不是更能看到问题所在了？两个组件大部分代码都是重复的唉。
按照上一节 wrapWithUsername 函数的思路，我们来写一个高阶组件(高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件)。

```js
import React, { Component } from "react";
export default (WrappedComponent) => {
  class NewComponent extends Component {
    constructor() {
      super();
      this.state = {
        username: "",
      };
    }
    componentWillMount() {
      let username = localStorage.getItem("username");
      this.setState({
        username: username,
      });
    }
    render() {
      return <WrappedComponent username={this.state.username} />;
    }
  }
  return NewComponent;
};
```

这样我们就能简化 Welcome 组件和 Goodbye 组件。

```js
import React, { Component } from "react";
import wrapWithUsername from "wrapWithUsername";
class Welcome extends Component {
  render() {
    return <div>welcome {this.props.username}</div>;
  }
}
Welcome = wrapWithUsername(Welcome);
export default Welcome;
import React, { Component } from "react";
import wrapWithUsername from "wrapWithUsername";

class Goodbye extends Component {
  render() {
    return <div>goodbye {this.props.username}</div>;
  }
}
Goodbye = wrapWithUsername(Goodbye);
export default Goodbye;
```

看到没有，高阶组件就是把 username 通过 props 传递给目标组件了。目标组件只管从 props 里面拿来用就好了。

> 到这里位置，高阶组件就讲完了。你再返回去理解下定义，是不是豁然开朗~

你现在理解 react-redux 的 connect 函数~

把 redux 的 state 和 action 创建函数，通过 props 注入给了 Component。
你在目标组件 Component 里面可以直接用 this.props 去调用 redux state 和 action 创建函数了。

```js
ConnectedComment = connect(mapStateToProps, mapDispatchToProps)(Component);
```

相当于这样

```js
// connect 是一个返回函数的函数（就是个高阶函数）
const enhance = connect(mapStateToProps, mapDispatchToProps);
// 返回的函数就是一个高阶组件，该高阶组件返回一个与 Redux store
// 关联起来的新组件
const ConnectedComment = enhance(Component);
antd 的 Form 也是一样的

const WrappedNormalLoginForm = Form.create()(NormalLoginForm);
```



## React VS Vue 以及各自的特点 优缺点

### React

#### 优点

- 引入了虚拟 DOM 和 diff 算法，提高了 Web 性能

`VDOM` :通过 JS 的对象模拟出 dom 的节点,然后通过 render 方法将虚拟 dom 转换成真实的 dom

算法复杂度为 O(n)
虚拟 dom 如何计算 diff
key 属性的作用

`Diff算法`:根据两个虚拟节点比较,返回一个 patch 对象,完成页面重新渲染

差异计算

先序深度优先遍历

#### 为什么更快了

当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。

- 组件化，模块化开发。便于我们后期维护性
- 单向数据流，比较有序，便于数据管理。

#### 缺点

- react 中只是 MVC 模式的 View 部分，所以在 react 开发中要依赖很多其他模块。

- 当父组件进行重新渲染时，即使子组件的 props 或 state 没有任何改变，也会同样进行重新渲染。（react 如何避免重复渲染）

#### 特点

1. 声明式设计（React 采用声明式，可以轻松描述应用。）
2. 高性能（React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。）
3. 灵活（React 可以与已知的库或框架很好地配合。）

#### 在 React 如何做性能优化？

1. 给 DOM 的遍历上加上唯一的 key。提高 diff 算法效率。
   尽量不要用 index,如果说在 DOM 中删了某一个节点，index 也就会发生变化，这时候就会重新渲染，所以 key 值最好使用 id。
2. 能用 const 声明的就用 const。在 render 里面尽量减少新变量的创建以及函数的指向改变问题。
3. 减少对真实 DOM 的操作。
4. 如果是用 webpack 搭建环境的话，当一个包过大加载过慢时，可分成多个包来优化。
5. 使用 react-loadable，按需加载路由
6. 定时器，超时器使用过后在 unmount 中清除。
7. immutable 对象管理状态 让状态不能被更改
8. 把 component 更换成 pureComponent 也可以进行优化

#### 你对 pureComponent 的理解

1. 当更新时，如果组件的 props 或者 state 都没有改变，render 函数就不会触发。
2. 省去虚拟 DOM 的生成和对比过程，达到提升性能的目的。
3. 具体原因是因为 react 自动帮我们做了一层浅比较

#### react 如何避免重复渲染

React 官方提供了 PureRenderMixin 插件，它的功能就是在不需要重新渲染的情况下让 shouldComponentUpdate 返回 false, 使用这个插件就能够减少不必要的重新渲染，性能得到也得到一些提升。

但是在 React 的新版本里面，提供了 React.PureComponent，而不需要使用这个插件。 所以说一个较大的组件决定重渲染的时候，我们可以在每一个子组件中绑定（新的）shouldComponentUpdate 方法，这样可以减少子组件重新渲染的次数。

#### 无状态组件和有状态组件有什么区别

**无状态组件**

> 无状态组件的创建形式使代码的可读性更好，而且减少了大量冗余的代码，以至于只有一个 render 方法。组件不会被实例化组件不能访问 this 对象，也不能访问生命周期方法无状态组件只能访问输入的 props ，同样的 props 渲染同样的结果，而且没有副作用。

**有状态组件**

> React.Component 创建的组件，其成员函数不会自动绑定 this，如果我们没有手动绑定 this，就不能获取当前组件实例对象。React.Component 创建的组件，其状态 state 是在 constructor 中像初始化组件属性一样去声明。

`补充：React.Component 有三种手动绑定方法`

```javascript
constructor(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this); //构造函数中绑定
}
```

```jsx
<div onClick={this.handleClick.bind(this)}></div> //使用 bind 来绑定
```

```jsx
<div onClick={() => this.handleClick()}></div> //使用 arrow function 来绑定
```

如何选择哪种方式创建组件只要有可能，尽量使用无状态组件。如果需要 state、生命周期方法等，使用 class 的创建组件

#### react 在哪个生命周期做优化?

可以在 shouldComponentUpdate 这个方法进行优化，用来判断是否调用 render 方法重绘 dom。
因为 dom 的重绘非常消耗性能，所以可以在这个方法中去做 dom 的 diff 算法的优化，这样就可以极大的提高性能。

但对于我们中级工程师来说，一般我不会去修改 shouldComponentUpdate 这个方法。而是直接去使用。True/false

#### react 组件间传值

- props 传值，父组件通过 props 向子组件传值，子组件通过回调函数向父组件传值
- redux 跨级通信。
- 通过 prop-types 的 context 实现跨级通信
  跨级组件间双向通信：使用 context 对象，根组件和其他所有子孙通信，不太适合组件间通信（可以实现，不好维护）
- 使用事件订阅实现非嵌套组件间通信，也可以实现跨级组件间通信

#### porps 和 state 的区别

`props`:组件中通讯使用,自上而下传递,只读
`state`:组件内的状态维护,可以更新子组件的 props

#### 对 react 中事件机制的理解

Reac 事件是合成事件，不是原生事件。

合成事件和原生事件的区别：

（1） 写法不同：合成事件是 camal 命名法，原生事件是全部小写

（2） 绑定位置不同：合成事件全部委派到 document 上，原生事件绑定到真实 dom 上。所以一般是在 componentDidMount 中或者 ref 回调函数中绑定，在 componentWillUnmount 阶段进行解绑，防止内存泄漏。

（3） 执行顺序不同：先执行原生事件，事件冒泡至 document 上，再执行合成事件。

#### react 在哪个生命周期做优化

可以在 shouldComponentUpdate 这个方法进行优化，用来判断是否调用 render 方法重绘 dom。
因为 dom 的重绘非常消耗性能，所以可以在这个方法中去做 dom 的 diff 算法的优化，这样就可以极大的提高性能。

但对于我们中级工程师来说，一般我不会去修改 shouldComponentUpdate 这个方法。而是直接去使用。True/false





## 关于setState

React的setState本身并不是异步的，是因为其批处理机制给人一种异步的假象。

【React的更新机制】

生命周期函数和合成事件中：

1. 无论调用多少次setState，都不会立即执行更新。而是将要更新的state存入'_pendingStateQuene',将要更新的组件存入'dirtyComponent';
2. 当根组件didMount后，批处理机制更新为false。此时再取出'_pendingStateQuene'和'dirtyComponent'中的state和组件进行合并更新；

原生事件和异步代码中：

1. 原生事件不会触发react的批处理机制，因而调用setState会直接更新；
2. 异步代码中调用setState，由于js的异步处理机制，异步代码会暂存，等待同步代码执行完毕再执行，此时react的批处理机制已经结束，因而直接更新。

总结：
react会表现出同步和异步的现象，但本质上是同步的，是其批处理机制造成了一种异步的假象。（其实完全可以在开发过程中，在合成事件和生命周期函数里，完全可以将其视为异步）

## HOC & Render Props & Hooks

### HOC

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/68747470733a2f2f692e696d6775722e636f6d2f4d3039667a674d2e706e67.png)

高阶组件其实并不是组件，只是一个函数而已。它接收一个组件作为参数，返回一个新的组件。我们可以在新的组件中做一些功能增加，渲染原有的组件。这样返回的组件增强了功能，但渲染与原有保持一致，没有破坏原有组件的逻辑。

因此在提取不同类别组件相似的行为时，高阶组件是非常合适的选择。举例说明的话，组件异步加载、异步加载 script 后显示组件、数据源绑定、拖拽排序。

### render props

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/68747470733a2f2f692e696d6775722e636f6d2f6f4938486732662e706e67.png)

去渲染一个父子组件，但是子组件依赖于父组件的某些数据: 可以在父组件中做一些通用性的逻辑，并将数据抛给子组件。子组件可以任意渲染成自己想要的样子。比如说我们可以在父组件中做一个倒计时的逻辑，然后把倒计时的时间传给子组件，这样子组件任意渲染成什么样都可以，子组件只自己知道会定时的拿到新的时间而已。

### Hooks

react hooks 的意义是：

- 代替 render props 这种 HOC 方式复用逻辑
- 代替生命周期函数，不再将逻辑散落在生命周期函数里
- 更加函数式，没有 class 也就少了副作用

看到 useEffect ，我想了想我对于副作用的理解：`UI = F(Props)` ，一个组件最终的dom结构与样式是由父级传递的props决定的。

「纯函数」:意思是固定的输入必然有固定的输出，它不依赖任何外部因素，也不会对外部环境产生影响。

react希望自己的组件渲染也是个纯函数，所以有了纯函数组件。然而真正的业务场景是有各种状态的，实际影响UI的还有内部的state。(其实还有context，暂时先不讨论）。

UI = F(props, state, context)

这个state可能会因为各种原因产生变化，从而导致组件的渲染结果不一致。相同的入参（props）下，每次render都有可能返回不同的UI。因此任何导致此现象的行为都是副作用（side effects）。比如用户点击下一页，导致页码与列表发生变化，这就是副作用。同样的props，不点击时是第一页数据，点击一下后，变成了第二页的数据or请求失败的页面or其他UI交互。

当然state是明面上影响了UI，暗地里，可能还有其他因素会影响UI。比如比如网络请求、操作 DOM等。

### hooks vs class

现在 hooks 让函数式组件完全可以代替 class 组件，用了 hooks 的函数组件可以很明显地看到两部分：**数据处理和 UI**，相比 class 组件中的混乱声明周期更高明一点。

> Hooks可以完全代替class 和HOC

![image](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/93757585-9ddc0900-fc39-11ea-9f3a-152b6312c3fd.png)

## React & Vue

#### 相同点

1. 都有组件开发和V-DOM
2. 都支持props进行父子组件数据通讯
3. 都是数据驱动,不直接操作真实dom,更新状态数据界面就自动更新
4. 都支持SSR
5. 都有native的方案,reactnative,weex

#### 不同点

1. 数据绑定:
   - vue是双向绑定(界面=>数据/数据=>界面)
   - react是单向数据流(数据=>界面)
2. 组件写法不一样
   - react推荐jsx
   - vue把所有东西写在模板里
3. 状态变化
   - react必须使用setState()更新组件状态
   - vue的data属性在vue对象中管理
4. VDOM实现不完全一样
   - vue会追踪所有依赖,不需要重新渲染整个组件树
5. React是MVC的View层,vue是MVVM的模式



## React 中 keys 的作用是什么？

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。

- 在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。
- 此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

## 调用 setState 之后发生了什么？

- 在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。

- 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。
- 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。



## shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）

shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。

参考react 性能优化-sf



## 为什么虚拟 dom 会提高性能?(必考)

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

参考 [如何理解虚拟 DOM?-zhihu](https://www.zhihu.com/question/29504639?sort=created)

## react diff 原理（常考）

- 把树形结构按照层级分解，只比较同级元素。
- 给列表结构的每个单元添加唯一的 key 属性，方便比较。
- React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
- 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

参考：React 的 diff 算法



## Diff

React Diff 会帮助我们计算出 Virtual DOM 中*真正发生变化的部分*，并且只针对该部分进行实际的DOM操作，而不是对整个页面进行重新渲染

### React diff算法策略

- 针对树结构(tree diff)：对UI层的DOM节点跨层级的操作进行忽略。（数量少）
- 针对组件结构(component diff)：拥有相同*类*的两个组件生成相似的树形结构，拥有不同*类*的两个组件会生成不同的属性结构。
- 针对元素结构(element-diff): 对于同一层级的一组节点，使用具有*唯一性*的id区分 (key属性)

#### tree diff 的特点

- React 通过使用 updateDepth 对 虚拟DOM树进行层次遍历
- 两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其所有子节点会被*完全删除*,不在进行进一步比较。
- 只需要遍历一次，便完成对整个DOM树的比较。

> React diff 只考虑*同层次*的节点位置变换,若为跨层级的位置变化，则是创建节点和删除节点的操作。即在新位置上重新创建相同的节点，而删除原位置的节点。

Tips:  React 官方建议不要进行DOM节点的跨层级操作，可是通过CSS来隐藏，显示节点，而不是真正地删除和添加DOM节点，保持稳定的DOM结构会对性能提升有帮助。

#### component diff的特点

- 同一类型的组件，按照原策略(tree diff)比较 virtual DOM tree
- 同类型组件，组件A转化为了组件B，如果virtual DOM 无变化，可以通过`shouldComponentUpdate()`方法来判断是否

> [React官方文档对于 shouldComponentUpdate的介绍](https://zh-hans.reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action)

- 不同类型的组件，那么diff算法会把要改变的组件判断为`dirty component`,从而替换整个组件的所有节点。

> 就算结构再相似的组件，只要 React 判断是不同的组件，就不会判断是否为不同类型的组件，就不会比较其结构，而是删除组件以及其子组件，并创建新的组件以及其子节点。

#### element diff特点

对于处于同一层级的节点，React diff 提供了三种节点操作: 插入，移动，删除

- 插入： 新的组件不在原来的集合中，而是全新的节点，则对集合进行插入操作。
- 删除：组件已经在集合中，但集合已经更新，此时节点就需要删除。
- 移动：组件*已经存在于*集合中，并且集合更新时，组件并没有发生更新，只是位置发生改变，例如：(A,B,C,D) → (A,D,B,C), 如果为*传统diff*则会在检测到旧集合中第二位为B，新集合第二位为D时删除B，插入D，并且后面的所有节点都要重新加载，而 React diff 则是通过向同一层的节点添加 *唯一key* 进行区分，并且移动。

#### 一些移动的场景与逻辑

##### 节点相同，位置不同

![diff 1](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/nT73TS.jpg)

按新集合中顺序开始遍历

1. B在新集合中 lastIndex(类似浮标) = 0, 在旧集合中 index = 1，index > `lastIndex` 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后`lastIndex` = max(index, lastIndex) = 1
2. A在旧集合中 index = 0， 此时 `lastIndex` = 1, 满足 index < `lastIndex`, 则对A进行移动操作，此时`lastIndex` = max(Index, lastIndex) = 1
3. D和B操作相同，同(1)，不进行移动，此时`lastIndex`=max(index, lastIndex) = 3
4. C和A操作相同，同(2)，进行移动，此时`lastIndex` = max(index, lastIndex) = 3

##### 节点位置均有变化

![diff 2](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/nT7GFg.jpg)

1.同上面那种情形，B不进行移动，`lastIndex`=1

2.新集合中取得E,发现旧中不存在E，在 `lastIndex`处创建E，`lastIndex`++

3.在旧集合中取到C，C不移动，`lastIndex`=2

4.在旧集合中取到A，A移动到新集合中的位置，`lastIndex`=2

5.完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但就集合中的节点(此例中为D)，删除D节点。

#### React diff 的不足之处

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/16d438cd5eec40c2.jpeg)

此例中D直接从最后一位提升至第一位，导致`lastIndex`在第一步直接提升为3，使ABC在进行index与lastIndex的判断时均处于 index < lastIndex 的情况，使ABC都需要做移动操作。所以我们应该减少将*最后一个*节点提升至*第一个*的操作，如果操作频率较大或者节点数量较多时，会对渲染性能产生影响。

### 小结

- React diff 与 传统diff 的不同是 React通过优化将O(n^3)提升至O(n)
- React 通过三个方面对tree diff, component diff, element diff 进行了优化
- 在开发时，尽量保持稳定的DOM结构，并且减少将最后的节点移动到首部的操作，能够优化渲染性能。





## React 中 refs 的作用是什么？

Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。

我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回

## (在构造函数中)调用 super(props) 的目的是什么

在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。

## 了解 redux 么，说一下 redux 把

- redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，
- 工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，
- flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰
- 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们

## redux 有什么缺点

- 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。
- 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。

## React性能优化

[链接](https://github.com/i-want-offer/FE-Interview-questions/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md)

#浏览器相关

## 介绍一下缓存


#### 浏览器缓存

这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。

浏览器缓存主要有以下几个优点(从客户端,服务端,网络 3 方面说)：

- Server端:减少重复数据请求,节省流量,降低服务器的压力,提高网站的性能。
- Client端:加快客户端加载网页的速度， 提升用户体验。

#### 缓存分类

1. 浏览器首先根据资源的 http 头信息判断是否命中强缓存,如果命中,就不用发请求到服务器,就到本地拿缓存文件.
2. 如果没有命中强缓存,浏览器就会发送请求到服务器,服务器来判断浏览器的本地缓存是否失效,若可以使用,服务器不会返回资源,浏览器继续从本地加载资源
3. 如果没有命中协商缓存,服务器就会完整返回资源给浏览器,浏览器加载资源,并更新缓存.

#### 强缓存

- 命中强缓存,返回 200,size 显示(from cache)
- 强缓存是利用 Expire 或者 Cache-Control 来控制
- 都是由服务端配置,如 nginx

`Expire`:缓存过期时间,是服务器的具体时间点.是绝对时间,有一个明显的缺点,当客户端本地时间更改

`Cache-Control`:是一个相对时间,同时启用,Cache-Control 优先级更高

#### 协商缓存

浏览器问服务器,问缓存的文件有没有更新

1. 没有更新,304,从缓存取
2. 更新了,重新从服务器拉取

`Last-Modified`:第一次请求服务器资源时,在响应头中,表示为资源最后修改时间

`If-Modify-Since`:当浏览器再次请求,在发送的请求头中,值与 Last-Modified 相等,服务器收到后,会根据最后修改时间判断是否命中缓存;如果命中返回 304,并且不会返回 Last-Modified.

`Etag/If-None-Match`:保证每个资源是唯一的,资源变化都会导致 Etag 变化.服务器根据浏览器发送过来的 If-None-Match 来判断是否命中缓存



> **如果同时设了 `ETag` 和 Last-Modified**
>
> 如果同时设了 `ETag` 和 `Last-Modified`，那么必须同时满足条件才会 304，不存在谁更优先就使用谁一说。

> **有了Last-Modified,为什么还要有Etag?**
>
> 1. 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。
> 2. 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。
> 3. 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。

> **关于Etag**
>
> 但一般分布式环境下（比如 CDN）很少使用 `ETag`，因为 `ETag` 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 `ETag` 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 `ETag`，并不绝对。

#### 浏览器缓存存放位置

![browser-cache](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/format,png-20200923002640150.png)

可看到有两个来源：

`memory cache`：内存中读取

`disk cache`：硬盘中读取

内存当然要比硬盘读取快，为啥会有存放硬盘呢？

因为内存浏览器内存有限啊，所以浏览器会有一套机制，根据文件大小何使用频率存放不同的位置，具体的实现取决于浏览器厂商，不过这微小对用户是无感知的。

### html的meta里设置缓存和http请求头设置缓存有什么区别吗

## 事件循环机制

https://github.com/i-want-offer/FE-Interview-questions/blob/master/JS/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.md)


## 介绍一下PWA

PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。（来自 MDN）

先看看 PWA 有哪些核心技术，就知道它有哪些优势了

#### App Shell

App Shell 架构是构建 Progressive Web App 的一种方式，这种应用能可靠且即时地加载到您的用户屏幕上，与本机应用相似。

这个模型包含界面所需要的最小资源文件，如果离线缓存，可以确保重复访问都有快速响应的特性，页面可快速渲染，网络仅仅获取数据。

或者这么理解， App Shell 就类似于原生app，没网络也可以本地启动。

#### ServiceWork

PWA 的核心，上面说到缓存可以让页面尽快加载，但必须有网络的情况下才行，没网络下还想加载网页咋办？

ServiceWork 持久的离线缓存的能力就可以实现。

Service Worker 有以下功能和特性：

- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context
- 一旦被 install，就永远存在，除非被手动 unregister
- 用到的时候可以直接唤醒，不用的时候自动睡眠
- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）
- 离线内容开发者可控
- 能向客户端推送消息
- 不能直接操作 DOM
- 必须在 HTTPS 环境下才能工作
- 异步实现，内部大都是通过 Promise 实现

js 是单线程的，ServiceWork 独立线程意味着不会阻塞js执行；可编程拦截代理请求和返回，可自定义文件缓存策略。

这些特点意味着开发者有足够的权限去操作缓存，让缓存做到优雅，效率达到极致

接下来核心是如何让设计缓存策略，

1. 缓存优先，先查询缓存，若存在，直接返回，不存在，请求服务，更新缓存
2. 服务端优先，不查询缓存，直接请求服务端，服务端失败才会查询缓存
3. 稳定优先，先查询缓存，有就读取，同时请求服务端更新资源

推荐大家看看开源的 wordbox 封装的缓存策略，策略更加丰富。

代码不复杂，主要是声明周期、与js线程间通信、api调用，就不贴上来了。

参考文档：

https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-introduction

https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps



## tcp/http/http2/tls/https/utp

#### TCP (Transmission Control Protocol)

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/v2-9cdd39da512d2a09a20aa77a05c6b0ad_1440w-20200922202955782.jpg)

##### 3次握手

`seq`:序号

`ack`:确认号

1. 客户端发送位码为syn=1,随机产生数据包到服务器，服务器由SYN=1知道客户端要求建立联机
2. 服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机生成数据包
3. 客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。

![截屏2020-09-22 下午9.13.10](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/截屏2020-09-22 下午9.13.10.png)

>  三次握手的原因是保证客户端和服务器都有发送和接收功能都是正常的

##### 4次挥手

1. 客户端发送请求给服务端，申请主动断开连接，进入等待状态，不在往服务端发送数据，但是接收数据（客户端：我要断开连接了）
2. 服务端收到后，告知客户端知道了，服务端进行等待状态，不在接收数据，但是可以继续发送数据（服务端：好，我知道了，但是要等一等）
3. 客户端收到服务端的告知后，进入下一阶段的等待。（客户端：好，我等）
4. 服务端完成剩余数据的发送后，告知客户端可以断开了，服务端不接收和读取数据（服务端：你可以断开了）
5. 客户端收到后，告知服务端，已收到，然后释放链接（客户端：好的，我断开链接了）
6. 服务端收到后，也释放链接

![截屏2020-09-22 下午8.59.14](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/截屏2020-09-22 下午8.59.14.png)

#### http1.1

超文本传输协议，用于发送请求，接受数据的网络协议，基于TCP/IP

支持 get/post/delete/head/options请求

存在的问题：

- 线头阻塞：TCP连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。

- 多个TCP连接
  虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。

- 头部冗余，采用文本格式
  HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。

- 客户端需要主动请求

#### http2

多路复用，服务器推送，头信息压缩，二进制协议

![70](/Users/yaqingteng/Desktop/前端面试/img/70.png)

#### 简单讲解一下 http2 的多路复用

在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

HTTP/2的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

#### https

http是明文传输，会出现中间人劫持

https结合了 对称加密+非对称加密+CA

>  步骤解释
>
>  1.浏览器给服务端发送SSL支持的版本，非对称加密算法，随机数1
>
>  2.服务器给浏览器协商好SSL版本，携带证书，随机数2
>
>  3.浏览器认证证书
>
>  4.，认证成功后浏览器发送随机数3，hash(第一步第二部的数据)
>
>  5，服务器验证hash数据，认证成功后将随机数123生成key，然后hash(之前的数据)=ZZ，把ZZ发送给浏览器
>
>  6.浏览器利用随机数123生成key，然后hash=ZZ ，对照服务器传过来的ZZ，如果一样就将随机数123生成key

![img](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/tls-four-handshake.png)

#### websocket

这个就问到了一次，所以简单进行了了解。

简单来说，WebSocket 是应用层协议，基于 tcp，与HTTP协议一样位于应用层，都是TCP/IP协议的子集。

![socket-tcp](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/format,png.jpeg)

HTTP 协议是单向通信协议，只有客户端发起HTTP请求，服务端才会返回数据。而 WebSocket 协议是双向通信协议，在建立连接之后，客户端和服务器都可以主动向对方发送或接受数据。

![socket-http](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/format,png-20200923165228493.png)

### tcp和udp的区别



## URL输入到渲染过程 

> 浏览器是按照URL进行网页缓存的,所以在输入后,能够击中强缓存则不进行请求
>
> 再者,能进入缓存一般dns都已经缓存到浏览器dns缓存中或者系统dns缓存中,.

#### 1. DNS查找

域名DNS解析，找到服务地址,其查找步骤如下,直到找到为止

- 浏览器DNS缓存
- 系统DNS缓存
- 路由器DNS缓存
- 网络运营商DNS缓存
- .com根域名服务器查找

> 如果fonts, images, scripts, ads, and metrics 都不同的主机名，DNS会对每一个进行查找。

#### 2. TCP Handshake

构建 TCP 连接(3次握手)，若有 https，则多一层 TLS 握手 .

>  TCP的”三次握手“技术经常被称为”SYN-SYN-ACK“—更确切的说是 SYN, SYN-ACK, ACK—因为通过TCP首先发送了三个消息进行协商，开始一个TCP会话在两台电脑之间。 是的，这意味着每台服务器之间还要来回发送三条消息，而请求尚未发出。

#### 3. TLS 协商(如果有)

#### 4. 发送http请求

#### 5. 接受响应

> 第一个响应包是14kb大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。
>
> 在"TCP slow start"中，在收到初始包之后, 服务器会将下一个包的大小加倍到大约28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。

#### 6.解析

一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。“推测性解析”，“解析”是浏览器将通过网络接收的数据转换为DOM和CSSOM的步骤，通过渲染器把DOM和CSSOM在屏幕上绘制成页面。

DOM是浏览器标记的内部表示。DOM也是被暴露的，可以通过JavaScript中的各种API进行DOM操作。

即使请求页面的HTML大于初始的14KB数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。这就是为什么在前14Kb中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的CSS和HTML）对于web性能优化来说是重要的。但是**在渲染到屏幕上面之前，HTML、CSS、JavaScript必须被解析完成。**

##### 构建DOM树

1生成DOM树

第一步,当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个CSS文件时，解析也可以继续进行，但是对于<script>标签（特别是没有 `async` 或者 `defer` 属性）会阻塞渲染并停止HTML的解析。尽管浏览器的**预加载扫描器**加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

> **预加载扫描器**
>
> 浏览器构建DOM树时，这个过程占用了主线程。当这种情况发生时，预加载扫描仪将解析可用的内容并请求高优先级资源，如CSS、JavaScript和web字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主HTML解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描仪提供的优化减少了阻塞。

##### 构建CSSOM树

第二步是处理CSS并构建CSSOM树。CSS对象模型和DOM是相似的。DOM和CSSOM是两棵树. 它们是独立的数据结构。浏览器将CSS规则转换为可以理解和使用的样式映射。浏览器遍历CSS中的每个规则集，根据CSS选择器创建具有父、子和兄弟关系的节点树。

##### JS编译

当CSS被解析并创建CSSOM时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用”Abstract Syntax Tree“并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的JavaScript编译。

#### 7. 渲染

渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的CSSOM树和DOM树组合成一个Render树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，**通过在GPU而不是CPU上绘制屏幕的一部分来提高性能**，从而释放主线程。

##### Style

第三步是将DOM和CSSOM组合成一个Render树，计算样式树或渲染树从DOM树的根开始构建，遍历每个可见节点。

> 像<head>和它的子节点以及任何具有`display: none`样式的结点，例如`script { display: none; }`（在user agent stylesheets可以看到这个样式）这些标签将不会显示，也就是它们不会出现在Render树上。具有`visibility: hidden`的节点会出现在Render树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理默认值，因此上面代码示例中的script节点将不会包含在Render树中。

##### layout

第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。

> 第一次确定节点的大小和位置称为**布局**。随后对节点大小和位置的重新计算称为**回流**。在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流。

##### paint

最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为[first meaningful paint](https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint)。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。浏览器需要非常快地完成这项工作。

> 绘制可以将布局树中的元素分解为多个层。将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括<video>和<canvas>，任何CSS属性为opacity、3D转换、`will-change`的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。

##### Compositing

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

当页面继续加载资产时，可能会发生回流（回想一下我们迟到的示例图像）,回流会触发重新绘制和重新组合。

如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。但我们没有包括图像大小！从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始.

#### CSS加载问题

根据页面渲染流程可得知:

1. css加载不会阻塞DOM树的解析;
2. css加载会阻塞DOM树的渲染;
3. css加载会阻塞后面js语句的执行;

#### 触发回流的场景

获取位置信息或者修改几何属性，如下：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 获取位置信息，因为需要回流计算最新的值

```javascript
// 获取位置信息相关属性
- offsetTop offsetLeft offsetWidth offsetHeight 相对于父级容器的偏移量
- scrollTop scrollLeft scrollWidth scrollHeight 相对于父级容器滚动上去的距离
- clientTop clientLeft clientWidth clientHeight 元素边框的厚度
- getComputedStyle()
- getBoundingClientRect
123456
```

#### 回流的优化

对树的局部甚至全局重新生成是非常耗性能的，所以要避免频繁触发回流

- 现代浏览器已经帮我们做了优化，采用队列存储多次的回流操作，然后批量执行，但获取布局信息例外，因为要获取到实时的数值，浏览器就必须要清空队列，立即执行回流。
- 编码上，避免连续多次修改，可通过合并修改，一次触发
- 对于大量不同的 dom 修改，可以先将其脱离文档流，比如使用绝对定位，或者 display:none ，在文档流外修改完成后再放回文档里中
- 通过节流和防抖控制触发频率
- css3 硬件加速，transform、opacity、filters，开启后，会新建渲染层

#### 开启GPU加速的方法

开启后，会将 dom 元素提升为独立的渲染层，它的变化不会再影响文档流中的布局。

- transform: translateZ(0)
- opacity
- filters
- Will-change

## 对称加密与非对称加密

#### 对称加密

对称加密是指双方持有相同的密钥进行通信，加密解密使用同一个钥匙，加密速度快，但是有一个安全问题，双方怎样获得相同的密钥？你总不能总是拿着U盘把密钥拷贝给对方吧。常见的对称加密算法有DES、3DES、AES等

#### 非对称加密

非对称加密，又称为公开密钥加密，是为了解决对称加密中的安全问题而诞生，一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢。

- 公钥(public key)是对外开放的，私钥(private key)是自己拥有的。
- 公钥(public key)加密的数据，只能用私钥(private key)解密。
- 私钥(private key)加密的数据，只能用公钥(public key)解密。

## http有哪些常见请求头

### 常见请求头

| Accept              | 可接受的响应内容类型（`Content-Types`）。                    | `Accept: text/plain`                                    | 固定       |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------- | ---------- |
| Accept-Charset      | 可接受的字符集                                               | `Accept-Charset: utf-8`                                 | 固定       |
| Accept-Encoding     | 可接受的响应内容的编码方式。                                 | `Accept-Encoding: gzip, deflate`                        | 固定       |
| Accept-Language     | 可接受的响应内容语言列表。                                   | `Accept-Language: en-US`                                | 固定       |
| Accept-Datetime     | 可接受的按照时间来表示的响应内容版本                         | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT          | 临时       |
| Authorization       | 用于表示HTTP协议中需要认证资源的认证信息                     | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==       | 固定       |
| Cache-Control       | 用来指定当前的请求/回复中的，是否使用缓存机制。              | `Cache-Control: no-cache`                               | 固定       |
| Connection          | 客户端（浏览器）想要优先使用的连接类型                       | `Connection: keep-alive``Connection: Upgrade`           | 固定       |
| Cookie              | 由之前服务器通过`Set-Cookie`（见下文）设置的一个HTTP协议Cookie | `Cookie: $Version=1; Skin=new;`                         | 固定：标准 |
| Content-Length      | 以8进制表示的请求体的长度                                    | `Content-Length: 348`                                   | 固定       |
| Content-MD5         | 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 | Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==                   | 废弃       |
| Content-Type        | 请求体的MIME类型 （用于POST和PUT请求中）                     | Content-Type: application/x-www-form-urlencoded         | 固定       |
| Date                | 发送该消息的日期和时间（以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT                     | 固定       |
| Expect              | 表示客户端要求服务器做出特定的行为                           | `Expect: 100-continue`                                  | 固定       |
| From                | 发起此请求的用户的邮件地址                                   | `From: user@itbilu.com`                                 | 固定       |
| Host                | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | `Host: www.itbilu.com:80``Host: www.itbilu.com`         | 固定       |
| If-Match            | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Modified-Since   | 允许在对应的资源未被修改的情况下返回304未修改                | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT        | 固定       |
| If-None-Match       | 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 | If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"       | 固定       |
| If-Range            | 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 | If-Range: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Unmodified-Since | 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。   | If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT      | 固定       |
| Max-Forwards        | 限制该消息可被代理及网关转发的次数。                         | `Max-Forwards: 10`                                      | 固定       |
| Origin              | 发起一个针对[跨域资源共享](http://itbilu.com/javascript/js/VkiXuUcC.html)的请求（该请求要求服务器在响应中加入一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源）。 | `Origin: http://www.itbilu.com`                         | 固定: 标准 |
| Pragma              | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 | `Pragma: no-cache`                                      | 固定       |
| Proxy-Authorization | 用于向代理进行认证的认证信息。                               | Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2== | 固定       |
| Range               | 表示请求某个实体的一部分，字节偏移以0开始。                  | `Range: bytes=500-999`                                  | 固定       |
| Referer             | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。`Referer`其实是`Referrer`这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用`Referer`了。 | Referer: http://itbilu.com/nodejs                       | 固定       |
| TE                  | 浏览器预期接受的传输时的编码方式：可使用回应协议头`Transfer-Encoding`中的值（还可以使用"trailers"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 | `TE: trailers,deflate`                                  | 固定       |
| User-Agent          | 浏览器的身份标识字符串                                       | `User-Agent: Mozilla/……`                                | 固定       |
| Upgrade             | 要求服务器升级到一个高版本协议。                             | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11          | 固定       |
| Via                 | 告诉服务器，这个请求是由哪些代理发出的。                     | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)          | 固定       |
| Warning             | 一个一般性的警告，表示在实体内容体中可能存在错误。           | Warning: 199 Miscellaneous warning                      | 固定       |

### 常见响应头

| 响应头                      | 说明                                                         | 示例                                                         | 状态       |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------- |
| Access-Control-Allow-Origin | 指定哪些网站可以`跨域源资源共享`                             | `Access-Control-Allow-Origin: *`                             | 临时       |
| Accept-Patch                | 指定服务器所支持的文档补丁格式                               | Accept-Patch: text/example;charset=utf-8                     | 固定       |
| Accept-Ranges               | 服务器所支持的内容范围                                       | `Accept-Ranges: bytes`                                       | 固定       |
| Age                         | 响应对象在代理缓存中存在的时间，以秒为单位                   | `Age: 12`                                                    | 固定       |
| Allow                       | 对于特定资源的有效动作;                                      | `Allow: GET, HEAD`                                           | 固定       |
| Cache-Control               | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | `Cache-Control: max-age=3600`                                | 固定       |
| Connection                  | 针对该连接所预期的选项                                       | `Connection: close`                                          | 固定       |
| Content-Disposition         | 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 | Content-Disposition: attachment; filename="fname.ext"        | 固定       |
| Content-Encoding            | 响应资源所使用的编码类型。                                   | `Content-Encoding: gzip`                                     | 固定       |
| Content-Language            | 响就内容所使用的语言                                         | `Content-Language: zh-cn`                                    | 固定       |
| Content-Length              | 响应消息体的长度，用8进制字节表示                            | `Content-Length: 348`                                        | 固定       |
| Content-Location            | 所返回的数据的一个候选位置                                   | `Content-Location: /index.htm`                               | 固定       |
| Content-MD5                 | 响应内容的二进制 MD5 散列值，以 Base64 方式编码              | Content-MD5: IDK0iSsgSW50ZWd0DiJUi==                         | 已淘汰     |
| Content-Range               | 如果是响应部分消息，表示属于完整消息的哪个部分               | Content-Range: bytes 21010-47021/47022                       | 固定       |
| Content-Type                | 当前内容的`MIME`类型                                         | Content-Type: text/html; charset=utf-8                       | 固定       |
| Date                        | 此条消息被发送时的日期和时间(以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来表示) | Date: Tue, 15 Nov 1994 08:12:31 GMT                          | 固定       |
| ETag                        | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  | ETag: "737060cd8c284d8af7ad3082f209582d"                     | 固定       |
| Expires                     | 指定一个日期/时间，超过该时间则认为此回应已经过期            | Expires: Thu, 01 Dec 1994 16:00:00 GMT                       | 固定: 标准 |
| Last-Modified               | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT                 | 固定       |
| Link                        | 用来表示与另一个资源之间的类型关系，此类型关系是在[RFC 5988](https://tools.ietf.org/html/rfc5988)中定义 | `Link: `; rel="alternate"                                    | 固定       |
| Location                    | 用于在进行重定向，或在创建了某个新资源时使用。               | Location: http://www.itbilu.com/nodejs                       | 固定       |
| P3P                         | P3P策略相关设置                                              | P3P: CP="This is not a P3P policy!                           | 固定       |
| Pragma                      | 与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果 | `Pragma: no-cache`                                           | 固定       |
| Proxy-Authenticate          | 要求在访问代理时提供身份认证信息。                           | `Proxy-Authenticate: Basic`                                  | 固定       |
| Public-Key-Pins             | 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值   | Public-Key-Pins: max-age=2592000; pin-sha256="……";           | 固定       |
| Refresh                     | 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 | Refresh: 5; url=http://itbilu.com                            |            |
| Retry-After                 | 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 | 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT | 固定       |
| Server                      | 服务器的名称                                                 | `Server: nginx/1.6.3`                                        | 固定       |
| Set-Cookie                  | 设置`HTTP cookie`                                            | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1           | 固定: 标准 |
| Status                      | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。   | `Status: 200 OK`                                             |            |
| Trailer                     | `Trailer`用户说明传输中分块编码的编码信息                    | `Trailer: Max-Forwards`                                      | 固定       |
| Transfer-Encoding           | 用表示实体传输给用户的编码形式。包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。 | Transfer-Encoding: chunked                                   | 固定       |
| Upgrade                     | 要求客户端升级到另一个高版本协议。                           | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               | 固定       |
| Vary                        | 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 | `Vary: *`                                                    | 固定       |
| Via                         | 告知代理服务器的客户端，当前响应是通过什么途径发送的。       | Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)                  | 固定       |
| Warning                     | 一般性警告，告知在实体内容体中可能存在错误。                 | Warning: 199 Miscellaneous warning                           | 固定       |
| WWW-Authenticate            | 表示在请求获取这个实体时应当使用的认证模式。                 | `WWW-Authenticate: Basic`                                    | 固定       |

## 报文提交Content-type的几种区别

| Content-type                                    | 描述                                            |
| ----------------------------------------------- | ----------------------------------------------- |
| Content-Type: application/json                  | json 字符串                                     |
| Content-Type: application/x-www-form-urlencoded | & 将 `key=value` 进行拼接， jquery 默认使用这个 |
| Content-Type: multipart/form-data               | 常用于文件上传                                  |



## 介绍下CORB

CORB (Cross origin read blocking)是一种判断是否要在跨站资源数据到达页面之前阻断其到达当前站点进程中的算法，降低了敏感数据暴露的风险。是站点隔离的一种实现机制，针对跨域标签，保护站点资源。

当跨域请求回来的数据 `MIME type` 同跨域标签应有的 `MIME` 类型不匹配时，浏览器会启动 `CORB` 保护数据不被泄漏，被保护的数据类型只有 `html xml json`。

#### minetype

MIME 是一个互联网标准，扩展了电子邮件标准，使其可以支持更多的消息类型。

常见 MIME 类型如：text/html text/plain image/png application/javascript ，用于标识返回消息属于哪一种文档类型。写法为 type/subtype。
在 HTTP 请求的响应头中，以 Content-Type: application/javascript; charset=UTF-8 的形式出现，MIME type 是 Content-Type 值的一部分

## 介绍下 viewport

用于做响应式web布局

<meta name="viewport" content="width=500, initial-scale=1">
这里只指定了两个属性，宽度和缩放，实际上 viewport 能控制的更多，它能表示的全部属性如下：
width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。

height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。

initial-scale：初始缩放比例。

minimum-scale：最小缩放比例。

maximum-scale：最大缩放比例。

user-scalable：是否允许用户缩放。

## 移动端300ms延时的原因? 如何处理?

因为在以前移动端双击可以缩放或者滑动，所以为了区分是点击还是双击，加了 300ms 的延迟。

解决方案：

- **css touch-action:** touch-action的默为 auto，将其置为 none 即可移除目标元素的 300 毫秒延迟 缺点: 新属性，可能存在浏览器兼容问题
- 利用touchstart和touchend来模拟click事件，缺点有点击穿透
- fastclick 原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
- 所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。

## Web Worker

## 浏览器性能监控

使用 `performance.timing` 这个api就可以获取到绝大部分性能相关的数据

![performance](/Users/yaqingteng/Desktop/前端面试/前端面试问题汇总.assets/format,png-20200923002401398.png)

- `navigationStart` ：在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
- `unloadEventStart` ：前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
- `redirectStart` ：第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0
- `redirectEnd` ：最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内的重定向才算，否则值为 0

#### 开始加载当前页面

- `fetchStart` ：浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前

#### 网络传输阶段 DNS TCP

- `domainLookupStart` ：DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
- `domainLookupEnd` ：DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
- `connectStart` :HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
- `secureConnectionStart` :HTTPS 连接开始的时间，如果不是安全连接，则值为 0
- `connectEnd` :HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间

#### 读取文档阶段

- `requestStart` :HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存,连接错误重连时，这里显示的也是新建立连接的时间
- `responseStart` :HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
- `responseEnd` :HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存

#### 解析文档阶段

- `domLoading` :开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
- `domInteractive` :完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
- `domContentLoadedEventStart` :DOM 解析完成后，网页内资源加载开始的时间,代表DOMContentLoaded事件触发的时间节点
- `domContentLoadedEventEnd` :DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕），文档的DOMContentLoaded 事件的结束时间，也就是jQuery中的domready时间；
- `domComplete` :DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
- `loadEventStart` :load 事件发送给文档，也即 load 回调函数开始执行的时间,如果没有绑定 load 事件，值为 0
- `loadEventEnd` :load 事件的回调函数执行完毕的时间,如果没有绑定 load 事件，值为 0

#### 各个阶段时间段查询

DNS查询耗时 = domainLookupEnd - domainLookupStart

TCP链接耗时 = connectEnd - connectStart

request请求耗时 = responseEnd - responseStart

解析dom树耗时 = domComplete - domInteractive

白屏时间 = domloadng - fetchStart

domready时间 = domContentLoadedEventEnd - fetchStart

onload时间 = loadEventEnd - fetchStart

## 举几个h5的新特性

- 新增语义化标签
- 新增api、本地存储
- css 边框、背景、动画

## 对于连续的中文输入有哪些事件

输入框对于输入连续中文的时候可以使用以下两个监听事件（第一次知道还有这个事件）:

compositionstart：事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）。

compositionend：当文本段落的组成完成或取消时,事件将被触发 (具有特殊字符的触发, 需要一系列键和其他输入, 如语音识别或移动中的字词建议)。

## webComponents

### 特点

- **Custom elements（自定义元素）：**一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。
- **Shadow DOM（影子DOM）**：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。
- **HTML templates（HTML模板）：** [` 和 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/slot) 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。

### 前景

- 但需要在组件中频繁操作 DOM 就变得不方便了。
- 主流前端框架都支持web components
- 但同时由于 `web components` 的标准暂时还是不稳定的，并且缺少文档、范例、教程，想要入门是一件相当困难的事情



## history 和 hash 路由

简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。
我们需要实现下满两点：

- 改变 url 且不让浏览器像服务器发送请求。
- 可以监听到 url 的变化
- 可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址

hash 模式和 history 模式，就是用来实现上面功能的

### Hash模式

在url后面加上#，如`http://127.0.0.1:5500/前端路由/hash.html#/page1`这个url后面的`#/page1`就是hash值

- hash 值的变化不会导致浏览器像服务器发送请求
- location.hash可以获取hash值
- hashchange是hash值发生改变的调用的函数

基于以上三点我们可以写一个路由实例

### History模式

History 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。

#### history基本api

- `history.go(n)`：路由跳转几步，n为2往前跳转2个页面，-2往后跳转两个页面
- `history.back()`：路由后退，相当于 `history.go(-1)`，用户可点击浏览器左上角的后退按钮模拟此方法
- `history.forward()`：路由前进，相当于 `history.go(1)`，用户可点击浏览器左上角的前进按钮模拟此方法

#### pushState()

`history.pushState()`：添加一条路由历史记录，**如果设置跨域网址则报错**

> `history.pushState`用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为：
> 	`state`:一个与指定网址相关的状态对象，`popstate`事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填`null`。
> 	`title`：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填`null`。
> 	`url`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。

#### window的popstate事件

当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。
需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）

### Hash 模式和 History 模式对比

Hash 模式是使用 URL 的 Hash 来模拟一个完整的 URL，因此当 URL 改变的时候页面并不会重载。History 模式则会直接改变 URL，所以在路由跳转的时候会丢失一些地址信息，在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源，比如跳转 index.html 什么的

#### hash路由 优缺点

- 优点
  - 实现简单，兼容性好（兼容到`ie8`）
  - 绝大多数前端框架均提供了给予`hash`的路由实现
  - 不需要服务器端进行任何设置和开发
  - 除了资源加载和`ajax`请求以外，不会发起其他请求
- 缺点
  - 对于部分需要重定向的操作，后端无法获取`hash`部分内容，导致后台无法取得`url`中的数据，典型的例子就是微信公众号的`oauth`验证
  - 服务器端无法准确跟踪前端路由信息
  - 对于需要锚点功能的需求会与目前路由机制冲突

#### History(browser)路由 优缺点

- 优点
  - 对于重定向过程中不会丢失`url`中的参数。后端可以拿到这部分数据
  - 绝大多数前段框架均提供了`browser`的路由实现
  - 后端可以准确跟踪路由信息
  - 可以使用`history.state`来获取当前`url`对应的状态信息
- 缺点
  - 兼容性不如`hash`路由(只兼容到`IE10`)
  - 需要后端支持，每次返回`html`文档

### 两种不同使用场景

- 从上文可见，hash模式下url会带有#，当你**希望url更优雅时**，可以使用history模式。
- 当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
- 当需要兼容**低版本的浏览器**时，建议使用hash模式。
- 当需要添加**任意类型数据**到记录时，可以使用history模式。




---

# NodeJS

## 怎么看nodejs可支持高并发



## koa & Express

#### Express：

优点：历史更久，文档更完整，资料更多，深入人心

缺点：不能忍的 callback

#### Koa：

优点： async await  

No Callback! No Callback! No Callback! 重要的事情说三遍！

缺点：Connect/Express 的中间件基本不能重用，基本要重写；依然需要更多人的支持和学习

###  

# 生产工具

git

webpack



# 问题汇总

给定一个单[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)，其中的元素按升序[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，将其转换为高度平衡的二叉搜索树。

sso单点登录

Vue双向数据绑定原理

#### 怎么判断元素进入窗体

#### 实现一个朋友圈那种一张图片占全部，两张图片分开，三张多张平铺的自适应。

#### 图片大小百分比，怎么把图片搞成正方形，纯CSS

#### redux状态管理机制

git的reset和revert有什么区别。

10.现在有一个宽高未知的父布局，以及一个未知宽高的子布局，实现水平垂直居中

17.手写快排

19.分析[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)时空复杂度

- window.requestAnimationFrame

MVVM原理是什么

1. 三次握手，在第二次握手的时候服务器和[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)在什么状态
1. new的时候做了什么，过程 写出来
2. 自适应和响应式
3. 用flex布局实现九宫格
4. 说说你常用到的git方法

 重载重写区别，应用场景



npm相关知识



try catch 以外的错误捕获

前端错误监控

src和href区别

options触发点,每次会不会option

事件机制

```

2020/9/28

面试官  17:09
<div id="div">
  <ul class="ul">
    <li class="li">test</li>
  </ul>
</div>

<script>
  document.getElementById("div").addEventListener(
  "click",
  e => {
    alert("div");
    // e.stopPropagation();
  },
  true
);

  document.querySelector(".ul").addEventListener("click", e => {
    alert("ul");
  });

  document.querySelector(".li").addEventListener("click", e => {
    alert("li");
  });

</script>

面试官  17:23
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

面试官  17:31
OPTIONS

面试官  17:35
{a: 1}

面试官  17:40
CSRF
```



实现一个 Promise.all 函数





### co库的执行原理

### 介绍模块化方案



# 面试过程

## 百度

### 一面[9/27 11:00]

问了项目的问题,解决了哪些难题

异步的方案

斐波那契数列的实现

函数给别人用需要注意哪些方向

promise.all实现

前端后端项目是怎么部署的

## 奥哲

### 一面[9/27 14:00]

觉得还可以

### 二面[9/10 14:00]





通知1-2天

GPU加速,以及分层





## 力达信[节后沟通]



## 腾讯

### 一面[9/27 17:00]

jsonp的原理怎么做

移动端事件

[JavaScript-词法作用域](https://blog.csdn.net/cgl_zyw/article/details/78414731)



# 店匠

团队来自百度国际化

2天内做技术面



# 并发调度器

```js
// JS实现一个带并发限制的异步调度器Scheduler，
// 保证同时运行的任务最多有两个。
// 完善代码中Scheduler类，
// 使得以下程序能正确输出

class Scheduler {
	constructor() {
		this.count = 2
		this.queue = []
		this.run = []
	}

	add(task) {
                 // ...
	}
}


const timeout = (time) => new Promise(resolve => {
	setTimeout(resolve, time)
})

const scheduler = new Scheduler()
const addTask = (time, order) => {
	scheduler.add(() => timeout(time)).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(400, '4')
// output: 2 3 1 4

// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```



```js
class Scheduler {
	constructor(count) {
		this.count = 2
		this.queue = []
		this.run = []
	}

	add(task) {
		this.queue.push(task)
		return this.schedule()
	}

	schedule() {
		if (this.run.length < this.count && this.queue.length) {
		  	const task = this.queue.shift()
		  	const promise = task().then(() => {
		  		this.run.splice(this.run.indexOf(promise), 1)
		  	})
		  	this.run.push(promise)
		  	return promise
		} else {
		  	return Promise.race(this.run).then(() => this.schedule())
		}
	}
}
```

